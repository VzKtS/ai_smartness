# V5.1 Specification: Full Context Continuity

## Overview

Extension du syst√®me hybride V5 pour assurer une **continuit√© parfaite entre sessions**. L'agent reprend exactement l√† o√π il en √©tait, avec une compr√©hension compl√®te du contexte de travail.

## Probl√®me R√©solu

Actuellement, lors d'une nouvelle session:
- L'agent re√ßoit les threads th√©matiquement pertinents
- Mais il manque le **contexte de travail en cours**
- L'agent ne sait pas: quels fichiers √©taient modifi√©s, quelle t√¢che √©tait en cours, quel est le r√¥le de l'utilisateur

## Architecture: 5 Layers d'Injection

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    INJECTION PRIORITY                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  [1] SESSION STATE      - Continuit√© imm√©diate de travail  ‚îÇ
‚îÇ  [2] WORK CONTEXT       - Contexte projet moyen terme      ‚îÇ
‚îÇ  [3] PINNED CONTENT     - Override explicite utilisateur   ‚îÇ
‚îÇ  [4] THREAD RELEVANCE   - M√©moire th√©matique s√©mantique    ‚îÇ
‚îÇ  [5] USER PROFILE       - Personnalisation persistante     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Layer 1: Session State

### Fichier: `.ai/session_state.json`

```json
{
  "session_id": "uuid",
  "started_at": "2025-01-15T14:00:00",
  "last_activity_at": "2025-01-15T14:45:00",
  "status": "idle",

  "current_work": {
    "thread_id": "thread_xyz",
    "thread_title": "Impl√©mentation V5",
    "last_user_message": "ok go",
    "last_agent_action": "Edit sur install.sh",
    "intent": "Finaliser la v5.0 et tester l'installation"
  },

  "files_modified": [
    {
      "path": "src/ai_smartness/install.sh",
      "action": "Edit",
      "timestamp": "2025-01-15T14:42:00",
      "summary": "Mise √† jour version v5.0"
    },
    {
      "path": "src/ai_smartness/mcp/server.py",
      "action": "Edit",
      "timestamp": "2025-01-15T14:30:00",
      "summary": "Ajout outils V5"
    }
  ],

  "pending_tasks": [
    "Sync et test de l'installation",
    "V√©rifier le daemon"
  ],

  "tool_history": [
    {"tool": "Read", "target": "install.sh", "at": "14:40:00"},
    {"tool": "Edit", "target": "install.sh", "at": "14:42:00"},
    {"tool": "Bash", "command": "git status", "at": "14:43:00"}
  ]
}
```

### Capture (hooks)

**PostToolUse** - Enrichir `capture.py`:
```python
def update_session_state(tool_name: str, tool_input: dict, tool_result: str):
    session_state = load_session_state()

    # Track file modifications
    if tool_name in ["Edit", "Write"]:
        file_path = tool_input.get("file_path", "")
        session_state["files_modified"].append({
            "path": file_path,
            "action": tool_name,
            "timestamp": datetime.now().isoformat(),
            "summary": extract_change_summary(tool_input, tool_result)
        })
        # Keep last 20 files
        session_state["files_modified"] = session_state["files_modified"][-20:]

    # Track tool history
    session_state["tool_history"].append({
        "tool": tool_name,
        "target": extract_target(tool_name, tool_input),
        "at": datetime.now().strftime("%H:%M:%S")
    })
    session_state["tool_history"] = session_state["tool_history"][-50:]

    session_state["last_activity_at"] = datetime.now().isoformat()
    save_session_state(session_state)
```

**UserPromptSubmit** - Enrichir `inject.py`:
```python
def update_session_from_prompt(user_message: str):
    session_state = load_session_state()
    session_state["current_work"]["last_user_message"] = user_message[:200]

    # Extract intent if message is directive
    if is_directive_message(user_message):
        session_state["current_work"]["intent"] = extract_intent(user_message)

    save_session_state(session_state)
```

**Heartbeat Idle Detection** - Dans `daemon/processor.py`:
```python
def check_session_idle():
    session_state = load_session_state()
    last_activity = parse_datetime(session_state["last_activity_at"])
    idle_minutes = (datetime.now() - last_activity).total_seconds() / 60

    if idle_minutes > 5 and session_state["status"] != "idle":
        session_state["status"] = "idle"
        session_state["ended_at"] = datetime.now().isoformat()
        # Snapshot for resume
        save_session_state(session_state)
```

---

## Layer 2: Work Context (Thread Enrichment)

### Extension du mod√®le Thread

```python
@dataclass
class Thread:
    # ... existing fields ...

    # V5.1: Work Context
    work_context: Optional[dict] = None

    def set_work_context(self, files: List[str], actions: List[str], goal: str):
        self.work_context = {
            "files": files[-10:],  # Last 10 files
            "actions": actions[-5:],  # Last 5 actions
            "goal": goal,
            "updated_at": datetime.now().isoformat()
        }

    def clear_work_context(self):
        """Called when thread is no longer hot"""
        self.work_context = None
```

### Synchronisation Session ‚Üí Thread

Quand un thread devient "hot" (actif), son `work_context` est mis √† jour depuis `session_state`:

```python
def sync_work_context_to_thread(session_state: dict, thread: Thread):
    if session_state["current_work"]["thread_id"] == thread.id:
        thread.set_work_context(
            files=[f["path"] for f in session_state["files_modified"]],
            actions=[t["tool"] + ":" + t["target"] for t in session_state["tool_history"][-5:]],
            goal=session_state["current_work"].get("intent", "")
        )
```

---

## Layer 3: Pinned Content

### Existant V5: `ai_pin()`

D√©j√† impl√©ment√©. Les pins sont stock√©s dans `.ai/pins.json`:

```json
{
  "pins": [
    {
      "id": "pin_abc",
      "content": "Je suis le d√©veloppeur principal d'AI Smartness",
      "priority": "high",
      "created_at": "2025-01-15T10:00:00",
      "expires_at": null
    }
  ]
}
```

### Injection

Les pins sont **toujours inject√©s** en priorit√© haute, sauf si expir√©s.

---

## Layer 4: Thread Relevance

### Existant V5

- Similarit√© s√©mantique (embeddings)
- Focus boost (topics prioritaires)
- Relevance score (feedback ratings)

Aucune modification requise.

---

## Layer 5: User Profile

### Fichier: `.ai/user_profile.json`

```json
{
  "created_at": "2025-01-10T09:00:00",
  "updated_at": "2025-01-15T14:00:00",

  "identity": {
    "role": "developer",
    "relationship": "owner",
    "name": null
  },

  "preferences": {
    "language": "fr",
    "verbosity": "concise",
    "emoji_usage": false,
    "technical_level": "expert"
  },

  "patterns": {
    "active_hours": ["09:00-12:00", "14:00-18:00"],
    "session_avg_duration_min": 35,
    "common_tasks": ["implementation", "debugging", "review"]
  },

  "context_rules": [
    "Toujours consid√©rer les alternatives avant correction rapide",
    "Pr√©f√®re les solutions simples"
  ]
}
```

### Apprentissage Automatique

```python
def update_user_profile_from_interaction(message: str, session_state: dict):
    profile = load_user_profile()

    # Detect role from interactions
    if "mon projet" in message.lower() or "j'ai cr√©√©" in message.lower():
        profile["identity"]["relationship"] = "owner"

    # Detect technical level
    technical_terms = count_technical_terms(message)
    if technical_terms > 5:
        profile["preferences"]["technical_level"] = "expert"

    # Update patterns
    current_hour = datetime.now().hour
    update_active_hours(profile, current_hour)

    save_user_profile(profile)
```

### MCP Tool: `ai_profile()`

```python
Tool(
    name="ai_profile",
    description="View or update user profile for personalized context",
    inputSchema={
        "type": "object",
        "properties": {
            "action": {
                "type": "string",
                "enum": ["view", "set_role", "set_preference", "add_rule"],
                "description": "Action to perform"
            },
            "key": {"type": "string"},
            "value": {"type": "string"}
        },
        "required": ["action"]
    }
)
```

---

## Smart Injection Logic

### Fichier: `hooks/inject.py` - Nouvelle logique

```python
def get_injection_context(user_message: str, ai_path: Path) -> str:
    """Build context injection based on layers and timing"""

    heartbeat = load_heartbeat(ai_path)
    session_state = load_session_state(ai_path)
    user_profile = load_user_profile(ai_path)
    pins = load_pins(ai_path)

    # Calculate time since last activity
    minutes_since_last = calculate_minutes_since(heartbeat)

    context_parts = []

    # === LAYER 1: Session State ===
    if minutes_since_last < 60:  # Within 1 hour
        session_context = build_session_context(session_state, minutes_since_last)
        if session_context:
            context_parts.append(session_context)

    # === LAYER 3: Pinned Content (always) ===
    active_pins = get_active_pins(pins)
    if active_pins:
        context_parts.append(build_pins_context(active_pins))

    # === LAYER 4: Thread Relevance ===
    thread_context = get_relevant_threads(
        user_message,
        focus_data=load_focus_data(ai_path),
        limit=calculate_thread_limit(minutes_since_last)
    )
    if thread_context:
        context_parts.append(thread_context)

    # === LAYER 5: User Profile (periodic reminder) ===
    if should_inject_profile(minutes_since_last, session_state):
        profile_context = build_profile_context(user_profile)
        if profile_context:
            context_parts.append(profile_context)

    return "\n\n".join(context_parts)


def build_session_context(session_state: dict, minutes_since: int) -> str:
    """Build session resumption context"""

    if not session_state.get("current_work"):
        return ""

    work = session_state["current_work"]
    files = session_state.get("files_modified", [])[-5:]
    tasks = session_state.get("pending_tasks", [])

    # Determine resumption type
    if minutes_since < 10:
        header = "üîÑ Reprise imm√©diate:"
    elif minutes_since < 30:
        header = "üîÑ Session pr√©c√©dente (il y a ~{} min):".format(minutes_since)
    else:
        header = "üîÑ Derni√®re session:"

    lines = [header]

    if work.get("thread_title"):
        lines.append(f"   Travail: \"{work['thread_title']}\"")

    if work.get("intent"):
        lines.append(f"   Objectif: {work['intent']}")

    if files:
        file_list = ", ".join([f["path"].split("/")[-1] for f in files[:3]])
        lines.append(f"   Fichiers: {file_list}")

    if tasks:
        lines.append(f"   En cours: {tasks[0]}")

    if work.get("last_agent_action"):
        lines.append(f"   Derni√®re action: {work['last_agent_action']}")

    return "\n".join(lines)


def calculate_thread_limit(minutes_since: int) -> int:
    """Adjust thread limit based on session continuity"""
    if minutes_since < 10:
        return 2  # Minimal threads, session state has context
    elif minutes_since < 60:
        return 3
    else:
        return 5  # Full thread context needed
```

### Injection Output Example

**Session < 10 min:**
```
üîÑ Reprise imm√©diate:
   Travail: "Impl√©mentation V5"
   Objectif: Finaliser la v5.0 et tester
   Fichiers: install.sh, server.py
   En cours: Sync et test de l'installation

üìå Pins:
   ‚Ä¢ Je suis le d√©veloppeur principal d'AI Smartness

üß† M√©moire:
   [1 thread pertinent au lieu de 5]
```

**Session > 1h:**
```
üìå Pins:
   ‚Ä¢ Je suis le d√©veloppeur principal d'AI Smartness

üß† M√©moire:
   [5 threads pertinents]

üë§ Profil: developer/owner, expert, pr√©f√®re solutions simples
```

---

## Fichiers √† Modifier/Cr√©er

### Nouveaux fichiers:
- `.ai/session_state.json` - Cr√©√© automatiquement
- `.ai/user_profile.json` - Cr√©√© automatiquement

### Modifications:

| Fichier | Modification |
|---------|-------------|
| `models/thread.py` | Ajouter `work_context` field |
| `hooks/capture.py` | Ajouter `update_session_state()` |
| `hooks/inject.py` | Nouvelle logique `get_injection_context()` |
| `daemon/processor.py` | Ajouter idle detection |
| `mcp/server.py` | Ajouter tool `ai_profile()` |
| `hooks/recall.py` | Documenter nouvelles features |

---

## Tests de Validation

### Sc√©nario 1: Reprise Imm√©diate (< 10 min)
1. Session A: Modifier install.sh, message "en cours de test"
2. Fermer session
3. Ouvrir session B apr√®s 5 min
4. **Attendu**: Agent dit "Je vois que tu testais install.sh, on continue?"

### Sc√©nario 2: Reprise Moyenne (10-60 min)
1. Session A: Travail sur feature X
2. Pause 30 min
3. Session B: Message "on reprend"
4. **Attendu**: Contexte r√©sum√© de la session pr√©c√©dente

### Sc√©nario 3: Nouvelle Session (> 1h)
1. Session apr√®s longue pause
2. **Attendu**: Threads th√©matiques + profil utilisateur, pas de session state

### Sc√©nario 4: User Profile Learning
1. Plusieurs sessions avec patterns similaires
2. **Attendu**: Profil enrichi avec role, preferences, patterns

---

## Migration V5 ‚Üí V5.1

- R√©trocompatible: nouveaux fichiers cr√©√©s automatiquement
- Pas de migration de donn√©es requise
- `session_state.json` initialis√© vide au premier hook
- `user_profile.json` initialis√© avec defaults

---

## Version

- **Version cible**: 5.1.0
- **D√©pendances**: V5.0 (pins, focus, ratings)
- **Breaking changes**: Aucun
